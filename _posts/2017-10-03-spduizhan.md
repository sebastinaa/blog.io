---
layout: post
title: 51单片机堆栈指针sp解析
date: 2017-10-03
categories: blog
tags: [记录]
description: Email:Jning@beamer.top
---

注：我们接下来要解决以下问题：什么是堆栈呢？他是如何运作的？堆栈是可以在哪个区域操作？它的命令有什么特点？

---

 （一）、**什么是堆栈？容量是多少？作用是什么？**
 
---

-在51单片机中，SP栈指针是一个专用的8位寄存器，系统复位后，SP初始化为07H，使得堆栈指针实际上是由08H单元开始。在响应中断或子程序调用时，发生入栈操作，入栈的是16位PC值。

-51的内部RAM只有从00H到7FH共计128字节的空间，而且00H~1FH是工作寄存器区， 所以SP的设定一般设定是从20H到70H这个范围。51堆栈的容量最大也不会超过128字节。 

-51中有**PUSH**压入和**POP**弹出栈操作指令，如有必要，在中断或调用子程序时可用PUSH指令把PSW或其它需要保护的寄存器的内容。压入堆栈加以保护；返回前再使用POP指令把它们恢复。

---

 （二）、**堆栈指针SP(Stack Pointer)**
 
---

 堆栈是一种数据结构，它是一个8位寄存器，它指示堆栈顶部在内部RAM中的位置。系统复位后，SP的初始值为07H，使得堆栈实际上是从08H开始的。但我们从RAM的结构分布中可知，08H—1FH隶属1—3工作寄存器区，若编程时需要用到这些数据单元，必须对堆栈指针SP进行初始化，原则上设在任何一个区域均可，但一般设在30H—1FH之间较为适宜。   
 
 数据的写入堆栈我们称为入栈（PUSH，有些文献也称作插入运算或压入），从堆栈中取出数据称为出栈（POP，也称为删除运算或弹出），堆栈的最主要特征是“后进先出”规则，也即最先入栈的数据放在堆栈的最底部，而最后入栈的数据放在栈的顶部，因此，最后入栈的数据出栈时则是最先的。这和我们往一个箱里存放书本一样，需将最先放入箱底部的书取出，必须先取走最上层的书籍。这个道理非常相似。  
 
 那么堆栈有何用途呢？堆栈的设立是为了中断操作和子程序的调用而用于保存数据的，即常说的断点保护和现场保护。微处理器无论是在转入子程序和中断服务程序的执行，执行完后，还是要回到主程序中来，在转入子程序和中断服务程序前，必须先将现场的数据进行保存起来，否则返回时，CPU并不知道原来的程序执行到哪一步，原来的中间结果如何？所以在转入执行其它子程序前，先将需要保存的数据压入堆栈中保存。以备返回时，再复原当时的数据。供主程序继续执行。   
 
 转入中断服务程序或子程序时，需要保存的数据可能有若干个，都需要一一地保留。如果微处理器进行多重子程序或中断服务程序嵌套，那么需保存的数据就更多，这要求堆栈还需要有相当的容量。否则会造成堆栈溢出，丢失应备份的数据。轻者使运算和执行结果错误，重则使整个程序紊乱。  
 
 MCS-51的堆栈是在RAM中开辟的，即堆栈要占据一定的RAM存储单元。同时MCS-51的堆栈可以由用户设置，SP的初始值不同，堆栈的位置则不一定，不同的设计人员，使用的堆栈区则不同，不同的应用要求，堆栈要求的容量也有所不同。堆栈的操作只有两种，即进栈和出栈，但不管是向堆栈写入数据还是从堆栈中读出数据，都是对栈顶单元进行的，SP就是即时指示出栈顶的位置（即地址）。在子程序调用和中断服务程序响应的开始和结束期间，CPU都是根据SP指示的地址与相应的RAM存储单元交换数据。  
 
 堆栈的操作有两种方法：其一是自动方式，即在中断服务程序响应或子程序调用时，返回地址自动进栈。当需要返回执行主程序时，返回的地址自动交给PC，以保证程序从断点处继续执行，这种方式是不需要编程人员干预的。第二种方式是人工指令方式，使用专有的堆栈操作指令进行进出栈操作，也只有两条指令：进栈为PUSH指令，在中断服务程序或子程序调用时作为现场保护。出栈操作POP指令，用于子程序完成时，为主程序恢复现场。 

---

 （三）、**什么是堆栈？MCS-51单片机的堆栈怎样设置的？**

---

 答：程序设计时，往往需要一个后进先出的RAM区，以保存CPU的现场。这种后进先出的缓冲区，就称为堆栈。 

 MCS-51单片的堆栈原则上设在内部RAM的任意区域内 。但是，一般设在**31H~7FH**的范围之间，栈顶的位置由栈指针SP指出。

---

 （四）、**51单片机堆栈操作指令举例说明**

---
 
 这4类指令的作用是把直接寻址单元的内容传送到堆栈指针SP所指的单元中，以及把SP所指单元的内容送到直接寻址单元中。这类指令只有两条，下述的第一条常称为入栈操作指令，第二条称为出栈操作指令。需要指出的是，单片机开机复位后，（SP）默认为07H，但一般都需要重新赋值，设置新的SP首址。入栈的第一个数据必须存放于SP+1所指存储单元，故实际的堆栈底为SP+1所指的存储单元。   
 
 堆栈操作指令有两条： 
     PUSH direct POP direct 

 第一条指令称之为推入，就是将direct中的内容送入堆栈中，第二条指令称之为弹出，就是将堆栈中的内容送回到direct中。推入指令的执行过程是，首先将SP中的值加1，然后把SP中的值当作地址，将direct中的值送进以SP中的值为地址的RAM单元中。例：    
 
     MOV SP，#5FH    MOV A，#100    MOV B，#20    PUSH ACC  
	 
     PUSH B     
	 
则执行第一条PUSH ACC指令是这样的：将SP中的值加1，即变为60H，然后将A中的值送到60H单元中，因此执行完本条指令后， 内存60H单元的值就是100，同样，执行PUSH B时，是将SP+1，即变为61H，然后将B中的值送入到61H单元中，即执行完本条指令后，61H单元中的值变为20。     

POP指令的在单片机中执行是这样的，首先将SP中的值作为地址，并将此地址中的数送到POP指令后面的那个direct中，然后SP减1。    

接上例：   
     POP B    
     POP ACC    
	 
 则执行过程是：将SP中的值（现在是61H）作为地址，取61H单元中的数值（现在是20），送到B中，所以执行完本条指令后B中的值是20，然后将SP减1，因此本条指令执行完后，SP的值变为60H，然后执行POP ACC，将SP中的值（60H）作为地址，从该地址中取数（现在是100），并送到ACC中，所以执行完本条指令后，ACC中的值是100。  

 这有什么意义呢？ACC中的值本来就是100，B中的值本来就是20，是的，在本例中，的确没有意义，但在实际工作中，则在PUSH B后一般要执行其他指令，而且这些指令会把A中的值，B中的值改掉，所以在程序的结束，如果我们要把A和B中的值恢复原值，那么这些指令就有意义了。 

 还有一个问题，如果我不用堆栈，比如说在PUSH ACC指令处用
 
     MOV 60H，A，
 
 在PUSH B处用指令
 
     MOV 61H，B，
  
 然后用
  
     MOV A，60H，MOV B，61H
  
 来替代两条POP指令，不是也一样吗？是的，从结果上看是一样的，但是从过程看是不一样的，PUSH和POP指令都是单字节，单周期指令，而MOV指令则是双字节，双周期指令。更何况，堆栈的作用不止于此，所以一般的计算机上都设有堆栈，单片机也是一样,而我们在编写子程序，需要保存数据时，常常也不采用后面的办法，而是用堆栈的办法来实现。  
 
例：写出以下单片机程序的运行结果
   
      MOV 30H，#12    
	  MOV 31H，#23    
	  PUSH 30H               
	  PUSH 31H    
	  POP 30H    
      POP 31H     
 
 结果是30H中的值变为23，而31H中的值则变为12。也就两者进行了数据交换。从这个例程能看出：使用堆栈时，入栈的书写次序和出栈的书写次序必须相反，才能保证数据被送回原位，不然就要出错了。  
 
 **另外特别注意事项**：   
 
 进行堆栈操作时，我们不能： 
 
     PUSH  R0 PUSH  R1 
 
 而只能： 
 
     PUSH  00H PUSH  01H  
	 
 POP direct指令也是一样。 

---

[关于我](http://beamer.top/about/)

这里有我的个人简介：[关于我](http://beamer.top/about/)

如果你想看到我最新的文章，可以关注我的csdn博客「lemaden520」[点此进入](http://blog.csdn.net/lemaden520/article/details/77657697)。
